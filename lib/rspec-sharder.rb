require 'rspec/core'

module RSpec
  module Sharder

    class ShardError < StandardError; end

    def self.run(total_shards:, shard_num:, rspec_args:)
      raise "fatal: invalid total shards: #{total_shards}" unless total_shards.is_a?(Integer) && total_shards > 0
      raise "fatal: invalid shard number: #{shard_num}" unless shard_num.is_a?(Integer) && shard_num > 0 && shard_num <= total_shards

      begin
        ::RSpec::Core::ConfigurationOptions.new(rspec_args).configure(::RSpec.configuration)

        return if ::RSpec.world.wants_to_quit

        ::RSpec.configuration.load_spec_files
      ensure
        ::RSpec.world.announce_filters
      end

      return ::RSpec.configuration.reporter.exit_early(::RSpec.configuration.failure_exit_code) if ::RSpec.world.wants_to_quit

      recorded_durations = load_recorded_durations

      begin
        example_groups = example_groups_for_shard(total_shards, shard_num, recorded_durations)
      rescue ShardError => e
        ::RSpec.configuration.error_stream.puts e.message
        exit ::RSpec.configuration.failure_exit_cod
      end

      example_count = ::RSpec.world.example_count(example_groups)

      new_durations = { }

      exit_code = ::RSpec.configuration.reporter.report(example_count) do |reporter|
        ::RSpec.configuration.with_suite_hooks do
          if example_count == 0 && ::RSpec.configuration.fail_if_no_examples
            return ::RSpec.configuration.failure_exit_code
          end

          group_results = example_groups.map do |example_group|
            start_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)
            result = example_group.run(reporter)
            end_time = Process.clock_gettime(Process::CLOCK_MONOTONIC)

            file_path = example_group.metadata[:file_path]
            new_durations[file_path] ||= 0
            new_durations[file_path] += (1000 * (end_time - start_time)).round

            result
          end

          success = group_results.all?
          exit_code = success ? 0 : 1
          if ::RSpec.world.non_example_failure
            success = false
            exit_code = ::RSpec.configuration.failure_exit_code
          end
          persist_example_statuses
          exit_code
        end
      end

      if exit_code == 0
        ::RSpec.configuration.output_stream.puts "\nWriting test durations to .spec_durations.txt.\n"
      else
        ::RSpec.configuration.output_stream.puts "\nNot writing test durations due to failures.\n"
      end

      ::RSpec.configuration.output_stream.puts file.puts "Durations:"
      new_durations.sort_by { |file_path, duration| file_path }.each do |file_path, duration|
        ::RSpec.configuration.output_stream.puts file.puts "#{file_path},#{duration}"
      end

      new_durations.each do |file_path, duration|
        recorded_durations[file_path] = duration
      end

      File.open(".spec_durations.txt", "w+") do |file|
        file.puts "# This file was generated by rspec-sharder #{Time.now.to_s}"
        file.puts <<~EOF
          # This file is used to create even test shards. It was updated by RSpec
          # Sharder on #{Time.now.to_s}. If test shards have become uneven, regenerate it:
          # 
          #   bundle exec rspec-sharder --help
        EOF
        recorded_durations.sort_by { |file_path, duration| file_path }.each do |file_path, duration|
          file.puts "#{file_path},#{duration}"
        end
      end

      exit exit_code
    end

    private

    def self.load_recorded_durations
      durations = { }

      if File.exist?('.spec_durations.txt')
        File.readlines('.spec_durations.txt').each_with_index do |line, index|
          line = line.strip

          if !line.start_with?('#') && !line.empty?
            parts = line.split(',')

            unless parts.length == 2
              raise ShardError.new("fatal: invalid .spec_durations.txt at line #{index + 1}")
            end

            file_path = parts[0].strip

            if file_path.empty?
              raise ShardError.new("fatal: invalid .spec_durations.txt at line #{index + 1}")
            end

            begin
              duration = Integer(parts[1])
            rescue ArgumentError => e
              raise ShardError.new("fatal: invalid .spec_durations.txt at line #{index + 1}")
            end

            durations[file_path] = duration
          end
        end.compact
      end

      durations
    end

    def self.example_groups_for_shard(total_shards, shard_num, durations)
      files = { }

      ::RSpec.world.ordered_example_groups.each do |example_group|
        file_path = example_group.metadata[:file_path]
        files[file_path] ||= 0
        if durations[file_path]
          files[file_path] = durations[file_path]
        else
          files[file_path] += ::RSpec.world.example_count([example_group]) * 1000
        end
      end

      shards = (1..total_shards).map { { size: 0, file_paths: [] } }

      # First sort by size to ensure large files are distributed evenly.
      # Next, sort by path to ensure each shard generates the shard lists deterministically.
      # Note that files is a map, sorting it turns it into an array of arrays.
      files = files.sort_by { |file_path, size| [size, file_path] }.reverse
      files.each do |file_path, size|
        shards.sort_by! { |shard| shard[:size] }
        shards[0][:file_paths] << file_path
        shards[0][:size] += size
      end

      shards.each_with_index do |shard, i|
        ::RSpec.configuration.output_stream.puts "Shard: #{i + 1}, Size: #{shard[:size]}, File Count: #{shard[:file_paths].size}, Files:"
        shard[:file_paths].each do |file_path|
          ::RSpec.configuration.output_stream.puts file_path
        end
        ::RSpec.configuration.output_stream.puts
      end

      shard_file_paths = shards[shard_num - 1][:file_paths]

      ::RSpec.world.ordered_example_groups.select do |example_group|
        shard_file_paths.include?(example_group.metadata[:file_path])
      end
    end

    def self.persist_example_statuses
      return if ::RSpec.configuration.dry_run
      return unless (path = ::RSpec.configuration.example_status_persistence_file_path)

      ::RSpec::Core::ExampleStatusPersister.persist(::RSpec.world.all_examples, path)
    rescue SystemCallError => e
      ::RSpec.configuration.error_stream.puts "warning: failed to write results to #{path}"
    end
  end
end
